{% extends "base.html" %}

{% block title %}
    Geospatial spanning tree
{% endblock %}

{% block content %}
            <div id="map" class="map"></div>
            <div id="popup" class="ol-popup">
                <a href="#" id="popup-closer" class="ol-popup-closer"></a>
                <div id="popup-content"></div>
            </div>

            <div id="info">&nbsp;</div>
{% endblock %}


{% block scripts %}
    <link rel="stylesheet" href="https://openlayers.org/en/v4.6.5/css/ol.css" type="text/css">

    <script src="{{ url_for('static', filename='js/vendor/jquery-1.11.2.min.js') }}"></script>
    <script src="{{ url_for('static', filename='js/vendor/jquery-ui-1.8.16.custom.min.js') }}"></script>
    <script src="{{ url_for('static', filename='js/vendor/jquery.event.drag-2.2.js') }}"></script>
    <script src="https://cdn.polyfill.io/v2/polyfill.min.js?features=requestAnimationFrame,Element.prototype.classList,URL"></script>
    <script src="https://openlayers.org/en/v4.6.5/build/ol.js"></script>
    <!-- <script src="https://openlayers.org/en/v5.0.0/build/ol.js"></script> -->
    <script type="text/javascript" src="http://maps.stamen.com/js/tile.stamen.js?v1.3.0"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/5.0.4/math.min.js"></script>

    <script>
    //////////////
    // UTILITIES
    //////////////

    function distance(lat1, lon1, lat2, lon2) {

        // Convert degrees to radians
        let latRad1 = lat1 * Math.PI / 180.0;
        let lonRad1 = lon1 * Math.PI / 180.0;

        let latRad2 = lat2 * Math.PI / 180.0;
        let lonRad2 = lon2 * Math.PI / 180.0;

        // radius of earth in metres
        let r = 6378100;

        // P
        let rho1 = r * Math.cos(latRad1);
        let z1 = r * Math.sin(latRad1);
        let x1 = rho1 * Math.cos(lonRad1);
        let y1 = rho1 * Math.sin(lonRad1);

        // Q.
        let rho2 = r * Math.cos(latRad2);
        let z2 = r * Math.sin(latRad2);
        let x2 = rho2 * Math.cos(lonRad2);
        let y2 = rho2 * Math.sin(lonRad2);

        // Dot product
        let dot = (x1 * x2 + y1 * y2 + z1 * z2);
        let cos_theta = dot / (r * r);

        let theta = Math.acos(cos_theta);

        // Distance in Metres
        return r * theta;
    }

    function to3dps(refVal) { return String(refVal.toFixed(3)); }

    function m2ml(m_val) { return Number(m_val) * 0.000621371; }

    function cloneArray( arr ) {
        let i, copy;

        if( Array.isArray( arr ) ) {
            copy = arr.slice( 0 );
            for( i = 0; i < copy.length; i++ ) {
                copy[ i ] = cloneArray( copy[ i ] );
            }
            return copy;
        } else if( typeof arr === 'object' ) {
            throw 'Cannot clone array containing an object!';
        } else {
            return arr;
        }

    }
    </script>


    <script>
    let coords = [];  // Points we set on the map; array
    let draw; // global so we can remove it later.
    let type_selected = "Point"; //Possible options are: Point, LineString,Polygon

    let container = document.getElementById('popup');
    let content = document.getElementById('popup-content');
    let closer = document.getElementById('popup-closer');

    ///////////////////////
    // COORDS INFORMATION
    ///////////////////////
    function display_coords() {
        let coords_as_html = "<tr><th>Index</th><th>Lat</th><th>Lon</th><tr>";
        $.each(coords, function( index, value ) {
          // console.log('>>>', index , value[0], value[1] );
          coords_as_html += "<tr><td>"+index+"</td><td>"+to3dps(value[0]) +"</td><td>"+to3dps(value[1])+"</td><tr>";
        });
        return '<table>'+coords_as_html+'</table>';
    }

    function display_coords_distances(){
        let html_result = "<tr><th>Src Id</th><th>Dst Id</th><th>Distance (miles)</th><tr>";
        for (i = 0; i < coords.length-1; i++) {
            for (j = i+1; j < coords.length; j++) {
                d = distance(coords[i][0],coords[i][1],coords[j][0],coords[j][1]);
                html_result+=
                    "<tr><td>"+i+"</td><td>"+j+"</td><td>"+
                        to3dps(m2ml(d))+"</td></tr>";
            }
        }
        return '<table>'+html_result+'</table>';
    }

    // Assume we dont go around the earth more than once...
    const def_dst = 50000.0; // Earth circumference is ~24900miles, ~39900km

    function sum(input){

        if (toString.call(input) !== "[object Array]")
            return false;

        let total =  0;
        for(i=0;i<input.length;i++)
        {
            if(isNaN(input[i]) || input[i] === def_dst){
                continue;
            }
            total += Number(input[i]);
        }
        return total;
    }

    function build_distance_matrix(){
        let dsts = [];
        for (i = 0; i < coords.length; i++) {
            let ref_row = [];
            for (j = 0; j < coords.length; j++) {
                if(j <= i){
                    ref_row[j] = def_dst;
                }
                else{
                    ref_row[j] = m2ml(distance(coords[i][0],coords[i][1],coords[j][0],coords[j][1]));
                }
            }
            dsts[i] = ref_row;
        }
        return dsts;
    }

    function deleteCol(arr, col_idx){
        for(var i = 0 ; i < arr.length ; i++)
        {
           arr[i].splice(col_idx, 1);
        }
        return arr;
    }

    function deleteRow(arr, row_idxs) {
        arr.splice(row_idxs, 1);
        return arr;
    }

    function splice_at_matrix_idx(ref_arr, idx){
        arr = cloneArray(ref_arr);
        return deleteRow(deleteCol(arr, idx), idx);
    }


    ///////////////////////
    //  MAP INTERACTIVITY
    ///////////////////////
    let raster = new ol.layer.Tile({
        source: new ol.source.Stamen({
            layer: 'terrain'
        })
    });

    let source = new ol.source.Vector({ wrapX: false });
    let vector = new ol.layer.Vector({
        source: source
    });

    let mousePositionControl = new ol.control.MousePosition({
        coordinateFormat: ol.coordinate.createStringXY(4),
        projection: 'EPSG:4326',
        undefinedHTML: '&nbsp;'
    });

    let overlay = new ol.Overlay({
        element: container,
        autoPan: true,
        autoPanAnimation: {
            duration: 250
        }
    });

    closer.onclick = function() {
        overlay.setPosition(undefined);
        closer.blur();
        return false;
    };

    let map = new ol.Map({
        controls: ol.control.defaults({
            attributionOptions: {
                collapsible: false
            }
        }).extend([mousePositionControl]),
        layers: [
            new ol.layer.Tile({
                source: new ol.source.Stamen({
                    layer: 'terrain'
                })
            }),
            new ol.layer.Tile({
                source: new ol.source.Stamen({
                    layer: 'terrain-labels'
                })
            }),

            raster,
            vector
        ],
        overlays: [overlay],
        target: 'map',
        view: new ol.View({
            // Center map on this location...  West of DC
            center: ol.proj.transform([-77.5, 39], 'EPSG:4326', 'EPSG:3857'),
            zoom: 10
        })
    });


    map.on('singleclick', function(evt) {
        let coordinate = evt.coordinate;
        let hdms = ol.coordinate.toStringHDMS(ol.proj.transform(
            coordinate, 'EPSG:3857', 'EPSG:4326'));

        overlay.setPosition(coordinate);

        let lonlat = ol.proj.transform(evt.coordinate, 'EPSG:3857', 'EPSG:4326');
        let lon = lonlat[0];
        let lat = lonlat[1];
        coords.push([lat, lon]);
        console.log("lat,lon=", lat, lon);

        content.innerHTML = '<form><table>'+
            '<tr><td>Lat:</td><td>' + to3dps(lat) + '</td></tr>'+
            '<tr><td>Lon:</td><td>' + to3dps(lon) + '</td></tr>'+
            '</table></form>';
    });



    function get_col_as_array(arr, col_idx){
        let col_arr = [];
        for(i=0; i<arr.length; i++){
            col_arr.push(arr[i][col_idx]);
        }
        return col_arr;
    }

    function find_row_idxs(arr, col_idx, ref_val){
        let row_idxs = -1;
        if (ref_val != def_dst){
            for(i=0; i<arr.length; i++){
                if(arr[i][col_idx] == ref_val) {
                    row_idxs = i;
                    break;
                }
            }
        }
        return row_idxs;
    }


    function find_path_at_node(dm, kruskal_idx){
        let ref_dsts = splice_at_matrix_idx(dm, kruskal_idx);

        let col_min_vals = math.min(ref_dsts, 0);

        // min lat, lon idx finder...
        let row_idxs = [];
        let min_idx = -1;
        for(dm_col=0; dm_col < dm.length; dm_col++){
            if(dm_col != kruskal_idx){
                min_idx++;
                row_idxs[dm_col] = find_row_idxs(dm, dm_col, col_min_vals[min_idx]);
            }else{
                console.log("In kruskal column:"+kruskal_idx);
                row_idxs[dm_col] = dm[kruskal_idx].indexOf(math.min(dm[kruskal_idx])); //-2;
            }
        }
        console.log(row_idxs);

        // for four locs on the map, kruskal = 2; row_idxs = [-1, 0, , 1] reads
        // '-1' is route not found,
        // '0', From loc idx '0' to col 1,
        // '_', kruskal row is 2
        // '1', From loc idx '1', to col 3
        /// from kruskal pos 3 to krusal 2

        return row_idxs;
    }

    function calc_path_distance(dm, row_idxs){
        let total_dist = 0.0;
        for(i=0; i<row_idxs.length; i++){
            let dist = 0.0;
            if(row_idxs[i] >= 0){
                if(row_idxs[i] > i)
                    dist = dm[i][row_idxs[i]];
                else
                    dist = dm[row_idxs[i]][i];
                console.log("From idx="+row_idxs[i]+" to idx="+i+", the distance is: "+dist);
                total_dist += dist;
            }
        }
        return total_dist;

    }


    map.on("dblclick", function(evt) {
        let pixel = evt.pixel;

        let output = display_coords() + display_coords_distances();
        $("#info").html(output);

        // let features = [];
        // map.forEachFeatureAtPixel(pixel, function(feature) {
        //     features.push(feature);
        // });
        // if (features.length > 0) {
        //     let coordinate = features[0].getGeometry().getFirstCoordinate();
        //     console.log(coordinate);
        // } else {
        //     document.getElementById("info").innerHTML = "&nbsp;";
        // }
        dm = build_distance_matrix();
        let paths = [];

        // let kruskal_idx = 3;
        for(kruskal_idx = 0; kruskal_idx < dm.length; kruskal_idx++){
            let row_idxs = find_path_at_node(dm, kruskal_idx);
            paths[kruskal_idx] = row_idxs;

            let total_dist = calc_path_distance(dm, paths[kruskal_idx]);
            console.log("Total distance at node idx "+kruskal_idx+" = "+to3dps(total_dist) + " miles");
        }

    });





    function addInteraction() {
        // This approach used since there is only one value set per window dropdown.
        let value = type_selected; //typeSelect.value;
        if (value !== 'None') {
            draw = new ol.interaction.Draw({
                source: source,
                type: type_selected
            });
            map.addInteraction(draw);
        }
    }
    addInteraction();

    </script>


{% endblock %}
